<!--
Application: Spaik Western Blot Analyzer
Version: 1.0.1 (Updated)
Date: 2025-05-27 (Updated)

Libraries Used:
- Tailwind CSS v3 (https://tailwindcss.com/)
  License: MIT License (https://opensource.org/licenses/MIT)
- tiff.js (https://github.com/seikichi/tiff.js)
  License: MIT License (https://github.com/seikichi/tiff.js/blob/master/LICENSE)
- ONNX Runtime Web (https://onnxruntime.ai/docs/api/js/)
  License: MIT License (https://github.com/microsoft/onnxruntime/blob/main/LICENSE)
- Chart.js (https://www.chartjs.org/)
  License: MIT License (https://github.com/chartjs/Chart.js/blob/master/LICENSE.md)
- SheetJS (xlsx.full.min.js) v0.20.3 (https://sheetjs.com/)
  License: Apache 2.0 (https://github.com/SheetJS/sheetjs/blob/master/LICENSE)

Developer: José Carlos González (SPAIK TECHNOLOGIES, S.L.) all rights reserved

This is a single-file HTML/JS application for Western Blot image analysis.
All JavaScript and CSS are inlined or linked via CDN.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaikWBTool</title>
    <script src="https://cdn.jsdelivr.net/npm/tiff.js/tiff.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
</head>
<body class="bg-gray-100 font-sans">

    <!-- MODIFIED HEADER -->
    <div class="bg-white text-gray-800 p-4 shadow-sm border-b border-gray-200 flex items-center gap-4">
        <a href="https://spaik.es" target="_blank" rel="noopener">
            <img src="https://www.spaik.es/static/media/logo-spaik-green-black.67f9a9337bd5b89586d840a04c2690e7.svg" alt="Spaik Logo" class="h-10">
        </a>
        <h1 class="text-2xl font-bold">Western Blot Analyzer</h1>
    </div>
    <!-- END MODIFIED HEADER -->

    <!-- MODIFIED: Added pb-14 for status bar height -->
    <div class="flex flex-col p-5 gap-5 min-h-screen pb-14">

        <!-- Row 1 -->
        <div class="flex gap-5">
            <!-- Left part of Row 1 -->
        <div class="w-96 flex-shrink-0 flex flex-col gap-5">
            <div id="loadDataSection" class="bg-white p-4 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-3 pb-2 border-b border-gray-200">1. Load Data</h2>
                    <label for="tifFileInput" class="block text-sm font-medium text-gray-700 mb-1">TIFF Image Folder:</label>
                    <div class="flex items-center gap-4 mb-3">
                        <!-- Visually hidden file input -->
                        <input type="file" id="tifFileInput" webkitdirectory directory accept=".tif,.tiff" class="hidden">
                        <!-- Custom button -->
                        <button type="button" id="customTifFolderButton" class="py-2 px-4 w-32 rounded-md border-0 text-sm font-semibold bg-blue-50 text-blue-700 hover:bg-blue-100 cursor-pointer">Choose folder</button>
                        <span id="tifFileCount" class="text-sm text-gray-600 whitespace-nowrap">No folder chosen</span>
                </div>
                <label for="onnxModelInput" class="block text-sm font-medium text-gray-700 mb-1">ONNX Model File (.onnx):</label>
                     <div class="flex items-center gap-4 mb-3">
                        <input type="file" id="onnxModelInput" accept=".onnx" class="block w-full text-sm text-gray-600 file:mr-4 file:py-2 file:px-4 file:w-32 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 file:cursor-pointer">
                    <span id="onnxFileName" class="text-sm text-gray-600 whitespace-nowrap"></span>
                </div>
                <button id="loadDataButton" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:shadow-md transition duration-150 ease-in-out">Load Data & Model</button>
            </div>
            <div id="exposurePreviewSection" class="bg-white p-4 rounded-lg shadow-md flex-grow flex flex-col" style="display:none;"> 
                <h2 class="text-xl font-semibold mb-3 pb-2 border-b border-gray-200">2. Exposure Preview</h2>
                <div class="flex-grow"> 
                    <div class="mb-2">
                        <label for="exposureSlider" id="exposureInfo" class="block text-sm font-medium text-gray-700 mb-1">Exposure Index: 0 (Time: 0s)</label> 
                    </div>
                    <input type="range" id="exposureSlider" min="0" max="0" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>
                <div id="currentFileNameDisplay" class="text-xs text-gray-500 mt-1">File: <span id="currentFileName">No file selected</span></div>
            </div>
            </div>
            <!-- Right part of Row 1 -->
            <div class="flex-1 flex flex-col gap-5">
                <div id="imagePreviewDisplay" class="bg-white p-4 rounded-lg shadow-md" style="display:none;">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold">Time Series Image Preview</h3>
                        <span id="imageExposureInfo" class="text-sm text-gray-600">Exposure Time: 0.0 seconds</span>
                    </div>
                    <div class="flex items-center justify-center min-h-[300px] bg-gray-50 rounded border border-gray-200 p-1">
                         <canvas id="timeSeriesCanvas" class="max-w-full max-h-full object-contain"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Row 2 -->
        <div class="flex gap-5">
            <!-- Left part of Row 2 -->
            <div class="w-96 flex-shrink-0 flex flex-col gap-5">
            <div id="backgroundCorrectionSection" class="bg-white p-4 rounded-lg shadow-md flex-grow flex flex-col" style="display:none;"> 
                <div class="flex-grow"> 
                    <h2 class="text-xl font-semibold mb-3 pb-2 border-b border-gray-200">3. Background Correction</h2>
                    <p class="text-sm text-gray-600 mb-3">Adjust the threshold to identify background pixels in the images. Higher values include more pixels as background. Click Apply when satisfied.</p>
                    <div class="flex items-center mb-3">
                        <label for="noiseThresholdSlider" class="text-sm font-medium text-gray-700 mr-2 whitespace-nowrap">Background Threshold:</label>
                        <input type="range" id="noiseThresholdSlider" min="0.001" max="0.05" step="0.001" value="0.015" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                        <span id="thresholdValue" class="ml-3 text-sm text-gray-700 min-w-[80px] text-right">0.015</span>
                    </div>
                </div>
                <button id="applyIntensitiesButton" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:shadow-md transition duration-150 ease-in-out">Apply & Calculate Intensities</button>
            </div>
                </div>
            <!-- Right part of Row 2 -->
            <div class="flex-1 flex gap-5">
                <div id="noisePlotsDisplay" class="flex gap-5 w-2/3" style="display:none;">
                    <div id="meanNoisePlotContainer" class="bg-white p-4 rounded-lg shadow-md w-1/2 flex flex-col">
                        <h3 class="text-lg font-semibold text-center mb-2 pb-2 border-b border-gray-200">Mean Noise vs. Exposure Time</h3>
                        <div class="flex-grow flex items-center justify-center min-h-[200px] bg-gray-50 rounded p-1 border border-gray-200">
                            <canvas id="noiseChartCanvas" class="max-w-full max-h-full object-contain"></canvas>
                        </div>
                    </div>
                    <div id="backgroundMaskContainer" class="bg-white p-4 rounded-lg shadow-md w-1/2 flex flex-col">
                        <h3 class="text-lg font-semibold text-center mb-2 pb-2 border-b border-gray-200">Background Mask</h3>
                        <div class="flex-grow flex items-center justify-center min-h-[200px] bg-gray-50 rounded p-1 border border-gray-200">
                             <canvas id="backgroundMaskCanvas" class="max-w-full max-h-full object-contain" style="image-rendering: pixelated;"></canvas>
                        </div>
                         <p class="text-center mt-1 text-sm text-gray-600">Dark gray areas = identified background</p>
                    </div>
                </div>
            
                <div id="reconstructedPreviewContainer" class="bg-white p-4 rounded-lg shadow-md w-1/3 flex flex-col" style="display:none;">
                    <h3 class="text-lg font-semibold mb-2 text-center pb-2 border-b border-gray-200">Reconstructed Image</h3>
                        <div class="flex-grow flex items-center justify-center min-h-[200px] bg-gray-50 rounded border border-gray-200 p-1">
                         <canvas id="reconstructedPreviewCanvas" class="max-w-full max-h-full object-contain"></canvas>
                        </div>
                     <p class="text-center mt-1 text-sm text-gray-600">Visual check</p>
                    </div>
            </div>
        </div>

        <!-- New Main Vertical Container for the two rows -->
        <div class="flex flex-col gap-5"> <!-- New Main Vertical Container for the two rows -->

            <!-- New Row 1: Crop Analysis vs BandSelection/Analysis Group -->
            <div class="flex gap-5">
                <!-- Left part of New Row 1 (for Crop Analysis) -->
                <div class="w-96 flex-shrink-0">
                    <div id="cropDataCaptureSection" class="bg-white p-4 rounded-lg shadow-md analysis-section flex flex-col h-full" style="display:none;">
                            <div class="flex justify-between items-center mb-3 pb-2 border-b border-gray-200">
                                <h2 class="text-xl font-semibold">4. Crop Analysis & Data Capture</h2>
                                <button id="manageCategoriesButton" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-1 px-2 rounded-md text-xs flex items-center justify-center" title="Manage Categories">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">
                                        <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.532 1.532 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.532 1.532 0 01.947-2.287c1.561-.379-1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106A1.532 1.532 0 0111.49 3.17zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                            <p class="text-sm text-gray-600 mb-3">Click on the image and select the band of interest to extract the intensity value. Fine-tune the position with the keyboard arrows. When the output is satisfactory, click "Save Current Value".</p>
                            
                        <label for="opt1Select" class="block text-sm font-medium text-gray-700 mb-1">Membrane:</label> <select id="opt1Select" class="w-full p-2 mb-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm"></select>
                        <label for="opt2Select" class="block text-sm font-medium text-gray-700 mb-1">Lane:</label> <select id="opt2Select" class="w-full p-2 mb-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm"></select>
                        <label for="opt3Select" class="block text-sm font-medium text-gray-700 mb-1">Protein:</label> <select id="opt3Select" class="w-full p-2 mb-3 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm"></select>
                        <button id="saveCurrentCropSumButton" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:shadow-md transition duration-150 ease-in-out">Save Current Value</button>
                     <div id="resultsLogContainer" class="mt-4 flex flex-col flex-1"> <!-- MOVED HERE -->
                        <h3 class="text-md font-semibold text-gray-800 mb-1">Saved Results Log:</h3>
                        <div id="resultsLog" class="p-2 bg-gray-50 border border-gray-200 rounded-md max-h-32 overflow-y-auto text-xs font-mono whitespace-pre-wrap flex-1">No results saved yet.</div>
                     </div>
                    </div>
                </div>
                <!-- Right part of New Row 1 (for BandSelAnalysisGroup) -->
                <div class="flex-1">
                    <div class="flex flex-row gap-5 h-full"> <!-- BandSelAnalysisGroup container - changed to flex-row -->
                        <div id="reconstructedImageDisplay" class="bg-white p-4 rounded-lg shadow-md w-3/5 flex flex-col flex-1" style="display:none;"> <!-- w-full back to w-3/5 -->
                                <div class="flex justify-between items-center mb-2">
                                    <h3 class="text-lg font-semibold">Band Selection</h3>
                                    <span id="reconstructedImageInfo" class="text-sm text-gray-600"></span>
                                </div>
                                <div class="flex items-center justify-center min-h-[300px] bg-gray-50 rounded border border-gray-200 p-1 flex-1">
                                    <canvas id="reconstructedIntensityCanvas" class="max-w-full max-h-full object-contain cursor-crosshair"></canvas>
                                </div>
                                <div id="reconstructedImageViewerControls" class="mt-3">
                                    <div class="text-center text-sm text-gray-700">Clicked Position (model input center): <span id="reconstructedClickedPosDisplay">(x: -, y: -)</span></div>
                                </div>
                                <div class="mt-3">
                                    <label for="bandSelectionDisplaySlider" id="bandSelectionDisplayInfo" class="block text-sm font-medium text-gray-700 mb-1">Display Exposure: Index 0 (Time: 0s)</label>
                                    <input type="range" id="bandSelectionDisplaySlider" min="0" max="0" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                                </div>
                        </div>
                        <div id="onnxCropAnalysisDisplay" class="bg-white p-4 rounded-lg shadow-md w-2/5 flex flex-col flex-1" style="display:none;"> <!-- w-full back to w-2/5 -->
                                <h3 class="text-lg font-semibold mb-3">Band Analysis</h3>
                                <div class="flex justify-center mb-3 flex-1">
                                    <div class="w-auto max-w-full p-1 bg-gray-50 border border-gray-200 rounded">
                                        <canvas id="cropSectionsCanvas" width="500" height="500" class="max-w-full max-h-full object-contain" style="image-rendering: crisp-edges;"></canvas>
                                    </div>
                                </div>
                                <div class="mb-2 flex items-center">
                                    <label for="horizontalSlider" class="w-40 text-sm font-medium text-gray-700">Horizontal Section:</label>
                                    <input type="range" id="horizontalSlider" min="0" max="63" value="32" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                                    <span id="horizontalValue" class="ml-3 w-8 text-sm text-gray-700 text-right">32</span>
                                </div>
                                <div class="flex items-center">
                                    <label for="verticalSlider" class="w-40 text-sm font-medium text-gray-700">Vertical Section:</label>
                                    <input type="range" id="verticalSlider" min="0" max="63" value="32" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                                    <span id="verticalValue" class="ml-3 w-8 text-sm text-gray-700 text-right">32</span>
                                </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- New Row 2: Export Results vs Saved Values Grid -->
            <div class="flex gap-5">
                <!-- Left part of New Row 2 (for Export Results) -->
                <div class="w-96 flex-shrink-0">
                    <div id="exportResultsSection" class="bg-white p-4 rounded-lg shadow-md analysis-section flex flex-col h-full" style="display:none;">
                        <h2 class="text-xl font-semibold mb-3 pb-2 border-b border-gray-200">5. Export Results</h2>
                        <label for="outputFileName" class="block text-sm font-medium text-gray-700 mb-1">File Name:</label>
                        <input type="text" id="outputFileName" value="wb_results.xlsx" class="w-full p-2 mb-3 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm">
                        <button id="exportToExcelButton" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:shadow-md transition duration-150 ease-in-out">Export to Excel</button>
                         <!-- MOVED FROM HERE -->
                    </div>
                </div>
                <!-- Right part of New Row 2 (for Saved Values Grid) -->
                <div class="flex-1 min-w-0"> <!-- Added min-w-0 -->
                    <div id="savedValuesTableSection" class="bg-white p-4 rounded-lg shadow-md flex flex-col h-full" style="display:none;">
                            <h3 class="text-lg font-semibold mb-3 pb-2 border-b border-gray-200">Saved Values Grid</h3>
                            <div class="overflow-auto flex-1"> <!-- Increased max-h, already flex-1 -->
                                <table id="savedValuesHtmlTable" class="min-w-full divide-y divide-gray-200 text-xs">
                                    <thead id="savedValuesTableHeader" class="bg-gray-100 sticky top-0 z-10">
                                        <!-- Header row will be populated by JS -->
                                    </thead>
                                    <tbody id="savedValuesTableBody" class="bg-white divide-y divide-gray-200">
                                        <!-- Data rows will be populated by JS. Initial placeholder: -->
                                        <tr><td colspan="3" class="px-3 py-2 text-center text-gray-500 italic">Grid will populate when data is loaded and categories are set.</td></tr>
                                    </tbody>
                                </table>
                            </div>
                    </div>
                </div>
            </div>

        </div>

    </div>

    <div id="setupControls" class="control-group" style="display:none !important;">Original Setup Controls - Will be removed</div>
    <div id="noiseAnalysisArea" class="control-group" style="display:none !important;">Original Noise Analysis - Will be removed</div>
    <div class="main-container" id="mainContainer" style="display:none !important;">Original Main Container - Will be removed</div>

    <!-- MODIFIED STATUS AREA: Thinner padding -->
    <div id="statusArea" class="fixed bottom-0 left-0 right-0 bg-white p-2 border-t border-gray-200 shadow-md z-50 text-center">
        <p class="m-0 text-sm">Status: <span id="statusText" class="italic text-gray-700">Ready. Select TIF files and ONNX model, then click "Load Data & Model".</span></p>
                    </div>

    <!-- ADDED: Modal for Managing Categories -->
    <div id="manageCategoriesModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center" style="display:none; z-index: 100;">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-semibold mb-6">Manage Categories</h2>
            
            <div class="mb-6 pb-4 border-b">
                <h3 class="text-lg font-medium text-gray-800 mb-3">Membrane Options</h3>
                <div id="currentMembraneOptionsContainer" class="mb-3 max-h-40 overflow-y-auto p-2 border rounded"></div>
                <div class="flex items-center gap-2">
                    <input type="text" id="newMembraneOptionInput" placeholder="New membrane name" class="flex-grow p-2 border border-gray-300 rounded-md text-sm">
                    <button id="addMembraneOptionButton" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 rounded-md text-sm">Add</button>
                    </div>
            </div>

            <div class="mb-6 pb-4 border-b">
                <h3 class="text-lg font-medium text-gray-800 mb-3">Lane Options</h3>
                <div id="currentLaneOptionsContainer" class="mb-3 max-h-40 overflow-y-auto p-2 border rounded"></div>
                <div class="flex items-center gap-2">
                    <input type="text" id="newLaneOptionInput" placeholder="New lane name" class="flex-grow p-2 border border-gray-300 rounded-md text-sm">
                    <button id="addLaneOptionButton" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 rounded-md text-sm">Add</button>
                </div>
            </div>

            <div class="mb-6">
                <h3 class="text-lg font-medium text-gray-800 mb-3">Protein Options</h3>
                <div id="currentProteinOptionsContainer" class="mb-3 max-h-40 overflow-y-auto p-2 border rounded"></div>
                <div class="flex items-center gap-2">
                    <input type="text" id="newProteinOptionInput" placeholder="New protein name" class="flex-grow p-2 border border-gray-300 rounded-md text-sm">
                    <button id="addProteinOptionButton" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 rounded-md text-sm">Add</button>
                </div>
            </div>

            <div class="mt-8 flex justify-end gap-3">
                <button id="cancelCategoryChangesButton" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-md">Cancel</button>
                <button id="saveCategoryChangesButton" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md">Save Changes</button>
        </div>
    </div>
    </div>

    <script>
        const MAX_TIF_VALUE = 2**16 - 1;
        const CROP_SIZE = 64;
        let BACKGROUND_THRESHOLD = 0.015;
        const SATURATION_THRESHOLD = 0.99; 
        
        let OPTIONS_1 = ["Membrane 1", "Membrane 2"];
        let OPTIONS_2 = ["Lane 1", "Lane 2", "Lane 3", "Lane 4", "Lane 5", "Lane 6", "Lane 7", "Lane 8", "Lane 9", "Lane 10"];
        let OPTIONS_3 = ["FH", "FHL1", "FHR-1beta", "FHR-1alfa", "FHR-2alfa", "FHR-2","FHR-3","FHR-4A","FHR-5"];

        const OPTIONS_1_KEY = 'wbAnalyzer_options1';
        const OPTIONS_2_KEY = 'wbAnalyzer_options2';
        const OPTIONS_3_KEY = 'wbAnalyzer_options3';

        let tempOptions1 = [];
        let tempOptions2 = [];
        let tempOptions3 = [];

        let isReconstructedPreviewUpToDate = false; 

        let tifFiles = [];
        let processedImagesData = []; 
        let currentImageIndex = 0;
        let onnxSession = null;
        let lastClickedPosition = { x: -1, y: -1 }; 
        let resultsDict = [];
        let noiseValues = []; 
        let exposureTimes = []; 
        let backgroundMask = null; 
        let noiseChart = null;
        let inputCropData = null;
        let outputCropData = null;
        let horizontalIndex = 32;
        let verticalIndex = 32;

        function getCentralPatchMax(cropData, cropSize = 64, patchSize = 8) {
            if (!cropData || cropData.length !== cropSize * cropSize) return 0.00001; 
            let maxVal = 0.0; 
            const startPixel = Math.floor(cropSize / 2) - Math.floor(patchSize / 2);
            const endPixel = startPixel + patchSize;

            for (let r = startPixel; r < endPixel; r++) {
                for (let c = startPixel; c < endPixel; c++) {
                    const val = cropData[r * cropSize + c];
                    if (val > maxVal) {
                        maxVal = val;
                    }
                }
            }
            return maxVal > 0 ? maxVal : 0.00001; 
        }

        function normalizeDataByMax(data, maxValue) {
            if (!data) return null; 
            const effectivelyZeroMax = maxValue < 0.0001; 

            const normalized = new Float32Array(data.length);
            for (let i = 0; i < data.length; i++) {
                if (effectivelyZeroMax) {
                     normalized[i] = 0.0; 
                } else {
                    normalized[i] = Math.min(1.0, data[i] / maxValue);
                }
            }
            return normalized;
        }

        let reconstructedIntensityData = null; 
        let meanNoiseValuesArray = []; 

        let reconstructedPreviewCanvas = null;
        let reconstructedPreviewCtx = null;

        let currentBandSelectionDisplayIndex = 0; 

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        const debouncedDrawCropSections = debounce(drawCropSections, 50);
        const debouncedHandleNoiseThresholdInteraction = debounce(handleNoiseThresholdInteraction, 250); 

        const tifFileInput = document.getElementById('tifFileInput');
        const onnxModelInput = document.getElementById('onnxModelInput');
        const loadDataButton = document.getElementById('loadDataButton');
        const tifFileCountDisplay = document.getElementById('tifFileCount');
        const onnxFileNameDisplay = document.getElementById('onnxFileName');
        const customTifFolderButton = document.getElementById('customTifFolderButton');
        const exposureSlider = document.getElementById('exposureSlider');
        const exposureInfo = document.getElementById('exposureInfo');
        const currentFileName = document.getElementById('currentFileName');
        const currentFileNameDisplay = document.getElementById('currentFileNameDisplay');
        const noiseThresholdSlider = document.getElementById('noiseThresholdSlider');
        const thresholdValue = document.getElementById('thresholdValue');
        const applyIntensitiesButton = document.getElementById('applyIntensitiesButton');
        const opt1Select = document.getElementById('opt1Select');
        const opt2Select = document.getElementById('opt2Select');
        const opt3Select = document.getElementById('opt3Select');
        const saveCurrentCropSumButton = document.getElementById('saveCurrentCropSumButton');
        const outputFileNameInput = document.getElementById('outputFileName');
        const exportToExcelButton = document.getElementById('exportToExcelButton');
        const resultsLog = document.getElementById('resultsLog');
        const timeSeriesCanvas = document.getElementById('timeSeriesCanvas'); 
        const timeSeriesCtx = timeSeriesCanvas.getContext('2d'); 
        const imageExposureInfo = document.getElementById('imageExposureInfo');
        // const clickedPosDisplay = document.getElementById('clickedPosDisplay'); // No longer used directly, remove if confirmed
        const reconstructedIntensityCanvas = document.getElementById('reconstructedIntensityCanvas');
        const reconstructedIntensityCtx = reconstructedIntensityCanvas.getContext('2d');
        const reconstructedClickedPosDisplay = document.getElementById('reconstructedClickedPosDisplay');
        const noiseChartCanvas = document.getElementById('noiseChartCanvas');
        const backgroundMaskCanvas = document.getElementById('backgroundMaskCanvas');
        const backgroundMaskCtx = backgroundMaskCanvas.getContext('2d');
        const cropSectionsCanvas = document.getElementById('cropSectionsCanvas');
        const cropSectionsCtx = cropSectionsCanvas.getContext('2d');
        const horizontalSlider = document.getElementById('horizontalSlider');
        const verticalSlider = document.getElementById('verticalSlider');
        const horizontalValue = document.getElementById('horizontalValue');
        const verticalValue = document.getElementById('verticalValue');
        const statusText = document.getElementById('statusText');
        const loadDataSection = document.getElementById('loadDataSection');
        const exposurePreviewSection = document.getElementById('exposurePreviewSection');
        const backgroundCorrectionSection = document.getElementById('backgroundCorrectionSection');
        const cropDataCaptureSection = document.getElementById('cropDataCaptureSection');
        const exportResultsSection = document.getElementById('exportResultsSection');
        const imagePreviewDisplay = document.getElementById('imagePreviewDisplay');
        const noisePlotsDisplay = document.getElementById('noisePlotsDisplay');
        const onnxCropAnalysisDisplay = document.getElementById('onnxCropAnalysisDisplay');
        const reconstructedImageDisplay = document.getElementById('reconstructedImageDisplay'); 
        const reconstructedPreviewContainer = document.getElementById('reconstructedPreviewContainer'); 
        const bandSelectionDisplaySlider = document.getElementById('bandSelectionDisplaySlider'); 
        const bandSelectionDisplayInfo = document.getElementById('bandSelectionDisplayInfo'); 
        const manageCategoriesModal = document.getElementById('manageCategoriesModal');
        const manageCategoriesButton = document.getElementById('manageCategoriesButton');
        const cancelCategoryChangesButton = document.getElementById('cancelCategoryChangesButton');
        const saveCategoryChangesButton = document.getElementById('saveCategoryChangesButton');
        const currentMembraneOptionsContainer = document.getElementById('currentMembraneOptionsContainer');
        const newMembraneOptionInput = document.getElementById('newMembraneOptionInput');
        const addMembraneOptionButton = document.getElementById('addMembraneOptionButton');
        const currentLaneOptionsContainer = document.getElementById('currentLaneOptionsContainer');
        const newLaneOptionInput = document.getElementById('newLaneOptionInput');
        const addLaneOptionButton = document.getElementById('addLaneOptionButton');
        const currentProteinOptionsContainer = document.getElementById('currentProteinOptionsContainer');
        const newProteinOptionInput = document.getElementById('newProteinOptionInput');
        const addProteinOptionButton = document.getElementById('addProteinOptionButton');
        
        let savedValuesTableSection = null;
        let savedValuesTableHeader = null; 
        let savedValuesTableBody = null;   


        function loadOptionsFromLocalStorage() {
            const storedOptions1 = localStorage.getItem(OPTIONS_1_KEY);
            if (storedOptions1) OPTIONS_1 = JSON.parse(storedOptions1);
            const storedOptions2 = localStorage.getItem(OPTIONS_2_KEY);
            if (storedOptions2) OPTIONS_2 = JSON.parse(storedOptions2);
            const storedOptions3 = localStorage.getItem(OPTIONS_3_KEY);
            if (storedOptions3) OPTIONS_3 = JSON.parse(storedOptions3);
        }

        function saveOptionsToLocalStorage() {
            localStorage.setItem(OPTIONS_1_KEY, JSON.stringify(OPTIONS_1));
            localStorage.setItem(OPTIONS_2_KEY, JSON.stringify(OPTIONS_2));
            localStorage.setItem(OPTIONS_3_KEY, JSON.stringify(OPTIONS_3));
        }

        function initialize() {
            loadOptionsFromLocalStorage(); 
            populateDropdowns();
            loadDataButton.addEventListener('click', handleLoadData);
            
            savedValuesTableSection = document.getElementById('savedValuesTableSection');
            savedValuesTableHeader = document.getElementById('savedValuesTableHeader'); 
            savedValuesTableBody = document.getElementById('savedValuesTableBody');     
            
            if (customTifFolderButton) {
                customTifFolderButton.addEventListener('click', () => {
                    tifFileInput.click();
                });
            }
            
            tifFileInput.addEventListener('change', () => {
                const allFiles = Array.from(tifFileInput.files);
                const validTifFiles = allFiles.filter(file => 
                    file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff')
                );
                tifFileCountDisplay.textContent = validTifFiles.length > 0 ? `(${validTifFiles.length} TIFF files)` : '(0 TIFF files)';
                if (customTifFolderButton) {
                    customTifFolderButton.classList.remove('bg-green-50', 'text-green-700', 'hover:bg-green-100');
                    customTifFolderButton.classList.add('bg-blue-50', 'text-blue-700', 'hover:bg-blue-100');
                }
            });
            onnxModelInput.addEventListener('change', () => {
                onnxFileNameDisplay.textContent = onnxModelInput.files.length > 0 ? `(${onnxModelInput.files[0].name})` : '';
                onnxModelInput.classList.remove('file:bg-green-50', 'file:text-green-700', 'hover:file:bg-green-100');
                onnxModelInput.classList.add('file:bg-blue-50', 'file:text-blue-700', 'hover:file:bg-blue-100');
            });

            exposureSlider.addEventListener('input', handleSliderChange); 
            noiseThresholdSlider.addEventListener('input', (event) => {
                localStorage.setItem('backgroundThreshold', event.target.value.toString());
                isReconstructedPreviewUpToDate = false; 
                if (reconstructedPreviewCanvas && reconstructedPreviewCtx) { 
                    reconstructedPreviewCtx.clearRect(0, 0, reconstructedPreviewCanvas.width, reconstructedPreviewCanvas.height); 
                }
                statusText.textContent = "Threshold changed. Click 'Apply & Calculate Intensities' to update and view reconstructed image.";
                debouncedHandleNoiseThresholdInteraction();
            });
            applyIntensitiesButton.addEventListener('click', () => {
                const currentThreshold = parseFloat(noiseThresholdSlider.value);
                BACKGROUND_THRESHOLD = currentThreshold;
                localStorage.setItem('backgroundThreshold', currentThreshold.toString());
                calculateAndDisplayReconstructedImage(true); 
            });

            saveCurrentCropSumButton.addEventListener('click', saveCurrentResult);
            exportToExcelButton.addEventListener('click', exportResultsToExcel);
            reconstructedIntensityCanvas.addEventListener('click', handleReconstructedCanvasClick);
            horizontalSlider.addEventListener('input', (event) => {
                handleHorizontalSliderChange(event);
                debouncedDrawCropSections();
            });
            verticalSlider.addEventListener('input', (event) => {
                handleVerticalSliderChange(event);
                debouncedDrawCropSections();
            });
            document.addEventListener('keydown', handleKeyDown);
            bandSelectionDisplaySlider.addEventListener('input', handleBandSelectionDisplaySliderChange); 

            reconstructedPreviewCanvas = document.getElementById('reconstructedPreviewCanvas'); 
            if (reconstructedPreviewCanvas) { 
                reconstructedPreviewCtx = reconstructedPreviewCanvas.getContext('2d');
            } else {
                console.error("Reconstructed Preview Canvas not found!");
            }
            
            const savedThreshold = localStorage.getItem('backgroundThreshold');
            if (savedThreshold) {
                const threshold = parseFloat(savedThreshold);
                noiseThresholdSlider.value = threshold;
                BACKGROUND_THRESHOLD = threshold;
            }
            updateThresholdDisplay(parseFloat(noiseThresholdSlider.value));

            horizontalValue.textContent = horizontalSlider.value;
            verticalValue.textContent = verticalSlider.value;

            if (manageCategoriesButton) {
                manageCategoriesButton.addEventListener('click', () => {
                    if (manageCategoriesModal) {
                        populateModalForEditing(); 
                        manageCategoriesModal.style.display = 'flex';
                    }
                });
            }
            if (cancelCategoryChangesButton) {
                cancelCategoryChangesButton.addEventListener('click', () => {
                    if (manageCategoriesModal) manageCategoriesModal.style.display = 'none';
                });
            }
            if (saveCategoryChangesButton) {
                saveCategoryChangesButton.addEventListener('click', () => {
                    OPTIONS_1 = [...tempOptions1];
                    OPTIONS_2 = [...tempOptions2];
                    OPTIONS_3 = [...tempOptions3];
                    
                    saveOptionsToLocalStorage();
                    populateDropdowns();
                    updateSavedValuesTable(); // Rebuild table with new categories
                    if (manageCategoriesModal) manageCategoriesModal.style.display = 'none';
                });
            }

            if (addMembraneOptionButton) {
                addMembraneOptionButton.addEventListener('click', () => {
                    const newValue = newMembraneOptionInput.value.trim();
                    if (newValue && !tempOptions1.includes(newValue)) {
                        tempOptions1.push(newValue);
                        renderCategoryOptionsInModal(tempOptions1, currentMembraneOptionsContainer, 'Membrane'); 
                        newMembraneOptionInput.value = '';
                    }
                });
            }
            if (addLaneOptionButton) {
                addLaneOptionButton.addEventListener('click', () => {
                    const newValue = newLaneOptionInput.value.trim();
                    if (newValue && !tempOptions2.includes(newValue)) {
                        tempOptions2.push(newValue);
                        renderCategoryOptionsInModal(tempOptions2, currentLaneOptionsContainer, 'Lane'); 
                        newLaneOptionInput.value = '';
                    }
                });
            }
            if (addProteinOptionButton) {
                addProteinOptionButton.addEventListener('click', () => {
                    const newValue = newProteinOptionInput.value.trim();
                    if (newValue && !tempOptions3.includes(newValue)) {
                        tempOptions3.push(newValue);
                        renderCategoryOptionsInModal(tempOptions3, currentProteinOptionsContainer, 'Protein'); 
                        newProteinOptionInput.value = '';
                    }
                });
            }
            updateSavedValuesTable(); 
        }

        function populateDropdowns() {
            opt1Select.innerHTML = '';
            opt2Select.innerHTML = '';
            opt3Select.innerHTML = '';
            OPTIONS_1.forEach(opt => opt1Select.add(new Option(opt, opt)));
            OPTIONS_2.forEach(opt => opt2Select.add(new Option(opt, opt)));
            OPTIONS_3.forEach(opt => opt3Select.add(new Option(opt, opt)));
        }

        function populateModalForEditing() {
            tempOptions1 = [...OPTIONS_1];
            tempOptions2 = [...OPTIONS_2];
            tempOptions3 = [...OPTIONS_3];
            renderCategoryOptionsInModal(tempOptions1, currentMembraneOptionsContainer, 'Membrane');
            renderCategoryOptionsInModal(tempOptions2, currentLaneOptionsContainer, 'Lane');
            renderCategoryOptionsInModal(tempOptions3, currentProteinOptionsContainer, 'Protein');
        }

        function renderCategoryOptionsInModal(optionsArray, container, categoryType) {
            container.innerHTML = ''; 
            if (optionsArray.length === 0) {
                container.textContent = 'No options defined.';
                container.classList.add('text-gray-500', 'italic');
                return;
            }
            container.classList.remove('text-gray-500', 'italic');
            const ul = document.createElement('ul');
            ul.className = 'list-disc pl-5 space-y-1';
            optionsArray.forEach((option, index) => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center py-1';
                const textSpan = document.createElement('span');
                textSpan.textContent = option;
                textSpan.className = 'text-sm';
                const removeButton = document.createElement('button');
                removeButton.textContent = 'Remove';
                removeButton.className = 'bg-red-500 hover:bg-red-600 text-white text-xs font-semibold py-1 px-2 rounded-md';
                removeButton.onclick = () => {
                    optionsArray.splice(index, 1); 
                    renderCategoryOptionsInModal(optionsArray, container, categoryType); 
                };
                li.appendChild(textSpan);
                li.appendChild(removeButton);
                ul.appendChild(li);
            });
            container.appendChild(ul);
        }

        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
                reader.readAsArrayBuffer(file);
            });
        }

        async function handleLoadData() {
            statusText.textContent = "Loading TIF images... (handleLoadData started)";
            const allSelectedFiles = Array.from(tifFileInput.files); 
            const validTifFiles = allSelectedFiles.filter(file => 
                file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff')
            );

            if (validTifFiles.length === 0) {
                statusText.textContent = "No TIFF files found in the selected folder.";
                tifFileCountDisplay.textContent = '(0 TIFF files)';
                 if (customTifFolderButton) {
                    customTifFolderButton.classList.remove('bg-green-50', 'text-green-700', 'hover:bg-green-100');
                    customTifFolderButton.classList.add('bg-blue-50', 'text-blue-700', 'hover:bg-blue-100');
                }
                return;
            }
            tifFiles = validTifFiles; 
            tifFileCountDisplay.textContent = `(${tifFiles.length} TIFF files)`;

            if (customTifFolderButton) {
                customTifFolderButton.classList.remove('bg-blue-50', 'text-blue-700', 'hover:bg-blue-100');
                customTifFolderButton.classList.add('bg-green-50', 'text-green-700', 'hover:bg-green-100');
            }

            let tempRawImages = [];
            for (let i = 0; i < tifFiles.length; i++) {
                const file = tifFiles[i];
                statusText.textContent = `Processing TIF ${i + 1}/${tifFiles.length}: ${file.name}...`;
                try {
                    const arrayBuffer = await readFileAsArrayBuffer(file);
                    const tiff = new Tiff({ buffer: arrayBuffer });
                    const width = tiff.width();
                    const height = tiff.height();
                    const exposure = extractExposureTime(file.name, i); 
                    let rawPixelDataArray;
                    let sourcePixelDataType = 'unknown';
                    let currentMaxValForFile = MAX_TIF_VALUE;
                    try {
                        const rasters = tiff.readRasters({ samples: [0] });
                        if (!rasters || !rasters[0] || rasters[0].length !== width * height) {
                            throw new Error("Invalid raster data from tiff.readRasters()");
                        }
                        const tiffData = rasters[0];
                        if (tiffData instanceof Uint8Array) {
                            sourcePixelDataType = 'uint8'; currentMaxValForFile = 255.0; rawPixelDataArray = new Float32Array(tiffData);
                        } else if (tiffData instanceof Uint16Array) {
                            sourcePixelDataType = 'uint16'; currentMaxValForFile = MAX_TIF_VALUE; rawPixelDataArray = new Float32Array(tiffData);
                        } else if (tiffData instanceof Float32Array) {
                            sourcePixelDataType = 'float32'; rawPixelDataArray = new Float32Array(tiffData); currentMaxValForFile = -1; 
                        } else {
                            throw new Error(`Unexpected raster data type: ${tiffData ? tiffData.constructor.name : 'undefined'}`);
                        }
                    } catch (rasterError) {
                        console.warn(`Error reading rasters for ${file.name}: ${rasterError.message}. Falling back to 8-bit canvas data.`);
                        const tempCanvas = tiff.toCanvas();
                        if (!tempCanvas) throw new Error("Fallback tiff.toCanvas() also failed.");
                        const tempCtx = tempCanvas.getContext('2d');
                        const imgDataFromCanvas = tempCtx.getImageData(0, 0, width, height);
                        rawPixelDataArray = new Float32Array(width * height);
                        for(let k=0; k < width*height; k++) rawPixelDataArray[k] = imgDataFromCanvas.data[k*4];
                        sourcePixelDataType = 'uint8_fallback'; currentMaxValForFile = 255.0;
                    }
                    tempRawImages.push({ name: file.name, width, height, rawFloatData: rawPixelDataArray, sourcePixelDataType: sourcePixelDataType, currentMaxValForFile: currentMaxValForFile, exposureTime: exposure });
                } catch (error) {
                    console.error(`Failed to process TIF ${file.name}:`, error);
                    statusText.textContent = `Error processing TIF ${file.name}: ${error.message}`;
                }
            }
            statusText.textContent = "TIF file reading complete. Inverting and sorting images...";
            let invertedImagesForSorting = tempRawImages.map(img => {
                const invertedData = new Float32Array(img.rawFloatData.length);
                let sumInverted = 0;
                for (let j = 0; j < img.rawFloatData.length; j++) {
                    let pixelVal = img.rawFloatData[j];
                    if (img.sourcePixelDataType === 'uint8' || img.sourcePixelDataType === 'uint8_fallback') {
                        pixelVal = pixelVal * (MAX_TIF_VALUE / 255.0);
                    }
                    invertedData[j] = MAX_TIF_VALUE - pixelVal;
                    sumInverted += invertedData[j];
                }
                return { name: img.name, width: img.width, height: img.height, invertedData: invertedData, sumInverted: sumInverted, originalExposureTime: img.exposureTime };
            });
            invertedImagesForSorting.sort((a, b) => a.sumInverted - b.sumInverted);
            statusText.textContent = "Sorting complete. Normalizing and structuring image data...";
            processedImagesData = [];
            exposureTimes = [];
            invertedImagesForSorting.forEach(img => {
                const normalizedDisplayData = new Float32Array(img.invertedData.length);
                for (let j = 0; j < img.invertedData.length; j++) {
                    normalizedDisplayData[j] = img.invertedData[j] / MAX_TIF_VALUE;
                    normalizedDisplayData[j] = Math.max(0.0, Math.min(1.0, normalizedDisplayData[j]));
                }
                processedImagesData.push({ name: img.name, width: img.width, height: img.height, data: normalizedDisplayData, exposureTime: img.originalExposureTime });
                exposureTimes.push(img.originalExposureTime);
            });
            
            if (processedImagesData.length > 0) { 
                statusText.textContent = `Normalization complete. ${processedImagesData.length} images processed. Updating UI...`;
                exposurePreviewSection.style.display = 'block';
                backgroundCorrectionSection.style.display = 'block';
                cropDataCaptureSection.style.display = 'block';
                exportResultsSection.style.display = 'block';
                imagePreviewDisplay.style.display = 'block'; 
                reconstructedImageDisplay.style.display = 'block'; 
                reconstructedPreviewContainer.style.display = 'block'; 
                noisePlotsDisplay.style.display = 'flex';
                onnxCropAnalysisDisplay.style.display = 'block';  
                if (savedValuesTableSection) { 
                    savedValuesTableSection.style.display = 'block';
                }
                tifFileInput.classList.remove('file:bg-blue-50', 'file:text-blue-700', 'hover:file:bg-blue-100');
                tifFileInput.classList.add('file:bg-green-50', 'file:text-green-700', 'hover:file:bg-green-100');
                currentImageIndex = 0; 
                exposureSlider.max = processedImagesData.length > 0 ? processedImagesData.length - 1 : 0;
                exposureSlider.value = currentImageIndex;
                updateExposureDisplays(); 
                displayTimeSeriesImage(); 
                currentBandSelectionDisplayIndex = 0; 
                bandSelectionDisplaySlider.max = processedImagesData.length > 0 ? processedImagesData.length - 1 : 0; 
                bandSelectionDisplaySlider.value = currentBandSelectionDisplayIndex; 
                updateBandSelectionDisplayInfo(); 
                statusText.textContent = `${processedImagesData.length} TIF image(s) loaded. Initial calculations starting...`;
                calculateAndDisplayReconstructedImage(false);
                updateSavedValuesTable(); 
                if (processedImagesData.length > 0 && onnxModelInput.files.length > 0 && onnxSession) {
                    statusText.textContent = `Data and model loaded. Adjust Background Threshold and click 'Apply & Calculate Intensities' to view reconstructed image.`;
                } else if (processedImagesData.length > 0) {
                    statusText.textContent = `Data loaded. ${onnxModelInput.files.length === 0 ? "ONNX model not selected. " : onnxSession === null ? "ONNX model failed to load. " : ""}Adjust Background Threshold and click 'Apply & Calculate Intensities'.`;
                }
            } else {
                statusText.textContent = "No TIF images were successfully processed after all steps.";
                console.warn("processedImagesData is empty after processing steps in handleLoadData.");
                return;
            }

            if (onnxModelInput.files.length > 0) {
                statusText.textContent += " Loading ONNX model...";
                try {
                    const modelFile = onnxModelInput.files[0];
                    const modelBuffer = await readFileAsArrayBuffer(modelFile);
                    onnxSession = await ort.InferenceSession.create(modelBuffer, { executionProviders: ['webgl', 'wasm'] });
                    statusText.textContent = `All images and ONNX model "${modelFile.name}" loaded. Ready for analysis.`;
                    onnxModelInput.classList.remove('file:bg-blue-50', 'file:text-blue-700', 'hover:file:bg-blue-100');
                    onnxModelInput.classList.add('file:bg-green-50', 'file:text-green-700', 'hover:file:bg-green-100');
                } catch (error) {
                    console.error("Error loading ONNX model:", error);
                    statusText.textContent = `Images loaded, but error loading ONNX model: ${error.message}`;
                    onnxSession = null;
                }
            } else {
                 statusText.textContent += " ONNX model file not selected. Some features disabled.";
                 onnxSession = null;
            }
        }
        
        function calculateAndDisplayReconstructedImage(isExplicitApply) {
            if (processedImagesData.length === 0) {
                statusText.textContent = "No TIF images loaded to calculate intensities.";
                if (reconstructedPreviewCanvas && reconstructedPreviewCtx) {
                    reconstructedPreviewCtx.clearRect(0, 0, reconstructedPreviewCanvas.width, reconstructedPreviewCanvas.height);
                }
                isReconstructedPreviewUpToDate = false;
                return;
            }
            if (isExplicitApply) {
                 statusText.textContent = "Calculating mean noise, mask, and reconstructed intensities...";
            } 
            const { means, mask, stats } = calculateMeanNoiseAndMask(processedImagesData, BACKGROUND_THRESHOLD);
            meanNoiseValuesArray = means; 
            backgroundMask = mask;       
            updateThresholdDisplay(BACKGROUND_THRESHOLD, stats.backgroundPercentage);
            statusText.textContent = "Mean noise calculation complete. Calculating reconstructed intensities...";
            const intensitiesResult = calculateReconstructedIntensities(processedImagesData, exposureTimes, meanNoiseValuesArray, SATURATION_THRESHOLD );
            reconstructedIntensityData = intensitiesResult; 
            if (reconstructedIntensityData) {
                drawBandSelectionDisplayImage(); 
                updateNoiseChart(); 
                drawBackgroundMaskVisualization(); 
                if (isExplicitApply) {
                    isReconstructedPreviewUpToDate = true; 
                    drawReconstructedPreviewImage(); 
                    statusText.textContent = "Analysis complete. Ready.";
                } else { 
                    isReconstructedPreviewUpToDate = false;
                    if (reconstructedPreviewCanvas && reconstructedPreviewCtx) { 
                        reconstructedPreviewCtx.clearRect(0, 0, reconstructedPreviewCanvas.width, reconstructedPreviewCanvas.height);
                    }
                }
                if (lastClickedPosition.x !== -1 && lastClickedPosition.y !== -1) {
                    updateAllCropsAndModel(); 
                }
            } else {
                statusText.textContent = "Failed to calculate reconstructed intensities (result was null).";
                isReconstructedPreviewUpToDate = false; 
                if (reconstructedPreviewCanvas && reconstructedPreviewCtx) { 
                    reconstructedPreviewCtx.clearRect(0, 0, reconstructedPreviewCanvas.width, reconstructedPreviewCanvas.height);
                }
            }
        }

        function calculateMeanNoiseAndMask(imagesDataArray, threshold) {
            if (imagesDataArray.length === 0) return { means: [], mask: null, stats: { backgroundPercentage: 'N/A'} };
            const width = imagesDataArray[0].width;
            const height = imagesDataArray[0].height;
            const numPixels = width * height;
            const numImages = imagesDataArray.length;
            const averageImage = new Float32Array(numPixels).fill(0);
            for (let i = 0; i < numImages; i++) {
                for (let px = 0; px < numPixels; px++) averageImage[px] += imagesDataArray[i].data[px];
            }
            for (let px = 0; px < numPixels; px++) averageImage[px] /= numImages;
            const newBgMask = new Uint8Array(numPixels);
            let backgroundPixelCountInMask = 0;
            for (let px = 0; px < numPixels; px++) {
                if (averageImage[px] < threshold) { newBgMask[px] = 1; backgroundPixelCountInMask++; } 
                else { newBgMask[px] = 0; }
            }
            const backgroundPercentage = numPixels > 0 ? (backgroundPixelCountInMask / numPixels * 100).toFixed(1) : '0.0';
            const newMeanNoiseValues = new Array(numImages).fill(0);
            for (let i = 0; i < numImages; i++) {
                let backgroundPixelsSum = 0; let count = 0;
                for (let px = 0; px < numPixels; px++) {
                    if (newBgMask[px] === 1) { backgroundPixelsSum += imagesDataArray[i].data[px]; count++; }
                }
                newMeanNoiseValues[i] = (count > 0) ? (backgroundPixelsSum / count) : 0;
            }
            return { means: newMeanNoiseValues, mask: newBgMask, stats: { backgroundPercentage: backgroundPercentage } };
        }

        function calculateReconstructedIntensities(imagesDataArray, exposuresArray, noiseValArray, satThreshold) {
            if (!imagesDataArray || imagesDataArray.length === 0 || imagesDataArray.length !== exposuresArray.length || imagesDataArray.length !== noiseValArray.length) return null;
            const width = imagesDataArray[0].width; const height = imagesDataArray[0].height; const numPixels = width * height; const numImages = imagesDataArray.length;
            const intensities = new Float32Array(numPixels);
            for (let px = 0; px < numPixels; px++) {
                let numerator = 0; let denominator = 0;
                for (let i = 0; i < numImages; i++) {
                    const denoisedValue = imagesDataArray[i].data[px] - noiseValArray[i];
                    if (denoisedValue < satThreshold && denoisedValue >= 0) {
                        numerator += exposuresArray[i] * denoisedValue; denominator += exposuresArray[i] * exposuresArray[i];
                    }
                }
                intensities[px] = (denominator === 0) ? 0 : (numerator / denominator);
            }
            let maxIntensity = -Infinity; let minIntensity = Infinity; let hasValidIntensity = false;
            for(let px=0; px < numPixels; px++) {
                if (!isNaN(intensities[px])) {
                    if (intensities[px] > maxIntensity) maxIntensity = intensities[px];
                    if (intensities[px] < minIntensity) minIntensity = intensities[px];
                    hasValidIntensity = true;
                }
            }
            minIntensity = Math.max(0, minIntensity); const normalizedIntensities = new Float32Array(numPixels);
            if (!hasValidIntensity) { normalizedIntensities.fill(0); } 
            else {
                 const range = maxIntensity - minIntensity;
                 for (let px = 0; px < numPixels; px++) {
                    if (isNaN(intensities[px])) { normalizedIntensities[px] = 1.0; } 
                    else {
                        if (range === 0) { normalizedIntensities[px] = (intensities[px] >= minIntensity && minIntensity > 0) ? 1.0 : 0.0; } 
                        else { normalizedIntensities[px] = (intensities[px] - minIntensity) / range; }
                        normalizedIntensities[px] = Math.max(0.0, Math.min(1.0, normalizedIntensities[px]));
                    }
                }
            }
            return { width: width, height: height, data: normalizedIntensities, isNormalized: true };
        }

        function displayTimeSeriesImage() {
            if (processedImagesData.length === 0 || !processedImagesData[currentImageIndex]) return;
            const img = processedImagesData[currentImageIndex];
            timeSeriesCanvas.width = img.width; timeSeriesCanvas.height = img.height;
            const imageData = timeSeriesCtx.createImageData(img.width, img.height);
            for (let i = 0; i < img.data.length; i++) {
                const val = Math.floor((1 - img.data[i]) * 255); 
                imageData.data[i * 4 + 0] = val; imageData.data[i * 4 + 1] = val; imageData.data[i * 4 + 2] = val; imageData.data[i * 4 + 3] = 255;
            }
            timeSeriesCtx.putImageData(imageData, 0, 0); updateExposureDisplays();
        }
        
        function updateExposureDisplays() {
            if (!processedImagesData || processedImagesData.length === 0 || !processedImagesData[currentImageIndex]) {
                exposureInfo.textContent = `Exposure Index: -`; currentFileName.textContent = "No file selected"; imageExposureInfo.textContent = `Exposure Time: N/A`; return;
            }
            const img = processedImagesData[currentImageIndex];
            const timeVal = (exposureTimes[currentImageIndex] !== undefined && typeof exposureTimes[currentImageIndex] === 'number') ? exposureTimes[currentImageIndex].toFixed(1) + "s" : "N/A";
            exposureInfo.textContent = `Exposure Index: ${parseInt(exposureSlider.value) + 1} of ${processedImagesData.length} (Time: ${timeVal})`;
            currentFileName.textContent = img.name; imageExposureInfo.textContent = `Exposure Time: ${timeVal}`;
        }

        function handleSliderChange() {
            currentImageIndex = parseInt(exposureSlider.value);
            displayTimeSeriesImage(); 
            if (noiseChart && meanNoiseValuesArray.length > 0 && meanNoiseValuesArray.length > currentImageIndex) {
                 const newDataset = {
                    ...noiseChart.data.datasets[0],
                    pointBackgroundColor: meanNoiseValuesArray.map((_, i) =>  
                        i === currentImageIndex ? 'rgba(255, 99, 132, 1)' : 'rgba(54, 162, 235, 1)'
                    ),
                    pointRadius: meanNoiseValuesArray.map((_, i) => 
                        i === currentImageIndex ? 7 : 5
                    )
                };
                noiseChart.data.datasets[0] = newDataset;
                noiseChart.update();
            }
        }

        function handleReconstructedCanvasClick(event) { 
            if (!processedImagesData || processedImagesData.length === 0 || !processedImagesData[currentBandSelectionDisplayIndex]) return;
            const sourceImageForClick = processedImagesData[currentBandSelectionDisplayIndex];

            const rect = reconstructedIntensityCanvas.getBoundingClientRect();
            const scaleX = sourceImageForClick.width / rect.width; 
            const scaleY = sourceImageForClick.height / rect.height;
            lastClickedPosition.x = Math.floor((event.clientX - rect.left) * scaleX);
            lastClickedPosition.y = Math.floor((event.clientY - rect.top) * scaleY);
            
            lastClickedPosition.x = Math.max(0, Math.min(sourceImageForClick.width -1 , lastClickedPosition.x));
            lastClickedPosition.y = Math.max(0, Math.min(sourceImageForClick.height -1, lastClickedPosition.y));

            reconstructedClickedPosDisplay.textContent = `(x: ${lastClickedPosition.x}, y: ${lastClickedPosition.y})`;
            horizontalIndex = 32; verticalIndex = 32;
            if (horizontalSlider) horizontalSlider.value = horizontalIndex; if (verticalSlider) verticalSlider.value = verticalIndex;
            if (horizontalValue) horizontalValue.textContent = horizontalIndex; if (verticalValue) verticalValue.textContent = verticalIndex;
            drawBandSelectionDisplayImage(); 
            updateAllCropsAndModel(); 
        }
        
        function adjustReconstructedPosition(dx, dy) { 
            if (!processedImagesData || processedImagesData.length === 0 || !processedImagesData[currentBandSelectionDisplayIndex]) return;
            const sourceImageForAdjust = processedImagesData[currentBandSelectionDisplayIndex];

            if (lastClickedPosition.x === -1 || lastClickedPosition.y === -1) { 
                lastClickedPosition.x = Math.floor(sourceImageForAdjust.width / 2);
                lastClickedPosition.y = Math.floor(sourceImageForAdjust.height / 2);
            }
            lastClickedPosition.x = Math.max(0, Math.min(sourceImageForAdjust.width - 1, lastClickedPosition.x + dx));
            lastClickedPosition.y = Math.max(0, Math.min(sourceImageForAdjust.height - 1, lastClickedPosition.y + dy));
            reconstructedClickedPosDisplay.textContent = `(x: ${lastClickedPosition.x}, y: ${lastClickedPosition.y})`;
            horizontalIndex = 32; verticalIndex = 32; 
            if (horizontalSlider) horizontalSlider.value = horizontalIndex; if (verticalSlider) verticalSlider.value = verticalIndex;
            if (horizontalValue) horizontalValue.textContent = horizontalIndex; if (verticalValue) verticalValue.textContent = verticalIndex;
            drawBandSelectionDisplayImage(); 
            updateAllCropsAndModel(); 
        }

        function handleKeyDown(event) {
            switch(event.key) {
                case 'ArrowUp': adjustReconstructedPosition(0, -1); event.preventDefault(); break;
                case 'ArrowDown': adjustReconstructedPosition(0, 1); event.preventDefault(); break;
                case 'ArrowLeft': adjustReconstructedPosition(-1, 0); event.preventDefault(); break;
                case 'ArrowRight': adjustReconstructedPosition(1, 0); event.preventDefault(); break;
            }
        }

        function extractCrop(sourceImageData, centerX, centerY, cropSize) { 
            const inputData = new Float32Array(cropSize * cropSize); inputData.fill(0.0); 
            const halfCrop = Math.floor(cropSize / 2);
            for (let y = 0; y < cropSize; y++) {
                for (let x = 0; x < cropSize; x++) {
                    const sourceX = centerX - halfCrop + x; const sourceY = centerY - halfCrop + y;
                    if (sourceX >= 0 && sourceX < sourceImageData.width && sourceY >= 0 && sourceY < sourceImageData.height) {
                        let pixelValue = sourceImageData.data[sourceY * sourceImageData.width + sourceX];
                        pixelValue = Math.max(0.0, Math.min(1.0, pixelValue)); 
                        inputData[y * cropSize + x] = pixelValue; 
                    }
                }
            }
            return inputData;
        }

        async function updateAllCropsAndModel() {
            if (lastClickedPosition.x === -1 || !reconstructedIntensityData || !reconstructedIntensityData.data) {
                if (cropSectionsCtx) cropSectionsCtx.clearRect(0, 0, cropSectionsCanvas.width, cropSectionsCanvas.height);
                inputCropData = null; outputCropData = null; drawCropSections(); return;
            }
            inputCropData = extractCrop(reconstructedIntensityData, lastClickedPosition.x, lastClickedPosition.y, CROP_SIZE);
            if (!onnxSession) { drawCropSections(); outputCropData = null; return; }
            try {
                statusText.textContent = "Running model inference...";
                const tensorInput = new ort.Tensor('float32', inputCropData, [1, 1, CROP_SIZE, CROP_SIZE]);
                const feeds = { [onnxSession.inputNames[0]]: tensorInput };
                const results = await onnxSession.run(feeds);
                const outputTensor = results[onnxSession.outputNames[0]];
                const rawOutputData = new Float32Array(outputTensor.data);
                outputCropData = new Float32Array(rawOutputData.length);
                for(let i=0; i < rawOutputData.length; i++) outputCropData[i] = Math.max(0, rawOutputData[i]);
                drawCropSections(); statusText.textContent = "Model inference complete.";
            } catch (error) {
                console.error("Error during ONNX inference:", error);
                statusText.textContent = `Error during ONNX inference: ${error.message}`;
                if (cropSectionsCtx) cropSectionsCtx.clearRect(0, 0, cropSectionsCanvas.width, cropSectionsCanvas.height);
                outputCropData = null; drawCropSections();
            }
        }

        function saveCurrentResult() {
            if (!inputCropData || !outputCropData || !reconstructedIntensityData) {
                alert("Cannot save result. Ensure a crop is selected, analyzed on the reconstructed image, and the ONNX model has run successfully."); return;
            }
            let currentOutputSum = 0;
            if (outputCropData) { for (let k = 0; k < outputCropData.length; k++) currentOutputSum += outputCropData[k]; }
            const result = {
                Membrane: opt1Select.value, Lane: opt2Select.value, Protein: opt3Select.value,
                SourceContext: "ReconstructedIntensity", 
                ClickedX: lastClickedPosition.x, ClickedY: lastClickedPosition.y,
                OutputCropSum: parseFloat(currentOutputSum.toFixed(4)) 
            };
            resultsDict.push(result);
            updateResultsLog();
            updateSavedValuesTable(); 
            statusText.textContent = "Result saved to log and grid.";
        }

        function updateResultsLog() {
            if (resultsDict.length === 0) { resultsLog.textContent = "No results saved yet."; return; }
            resultsLog.textContent = resultsDict.map(r => 
                `M: ${r.Membrane}, L: ${r.Lane}, P: ${r.Protein}, Sum: ${r.OutputCropSum.toFixed(4)} (X:${r.ClickedX},Y:${r.ClickedY})`
            ).join('\n');
        }

        function exportResultsToExcel() {
            if (resultsDict.length === 0) { alert("No results to export."); return; }
            const headerRow = ["", ""].concat(OPTIONS_2); const aoa = [headerRow]; 
            OPTIONS_1.forEach(membrane => {
                OPTIONS_3.forEach((protein, proteinIndex) => {
                    const row = [];
                    row.push(proteinIndex === 0 ? membrane : ""); row.push(protein);
                    OPTIONS_2.forEach(lane => {
                        const resultEntry = resultsDict.find(r => r.Membrane === membrane && r.Protein === protein && r.Lane === lane);
                        row.push(resultEntry ? (resultEntry.OutputCropSum === 0.0 ? null : resultEntry.OutputCropSum) : null); 
                    });
                    aoa.push(row);
                });
            });
            const ws = XLSX.utils.aoa_to_sheet(aoa); const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Results");
            let filename = outputFileNameInput.value || "wb_results.xlsx";
            if (!filename.toLowerCase().endsWith('.xlsx')) filename += ".xlsx";
            XLSX.writeFile(wb, filename); statusText.textContent = `Results exported to ${filename}.`;
        }
        
        function extractExposureTime(filename, fallbackIndex) {
            const match = filename.match(/(\d+(?:\.\d+)?)/); return match ? parseFloat(match[1]) : fallbackIndex;
        }

        function updateThresholdDisplay(threshold, backgroundPercentage = null) {
            let displayText = threshold.toFixed(3);
            if (backgroundPercentage !== null) displayText += `<br><span class='text-xs text-gray-500'>(${backgroundPercentage}% background)</span>`;
            thresholdValue.innerHTML = displayText;
        }
        
        function drawBackgroundMaskVisualization() {
            if (!processedImagesData[currentImageIndex] || !backgroundMask) {
                 if(backgroundMaskCtx) backgroundMaskCtx.clearRect(0,0, backgroundMaskCanvas.width, backgroundMaskCanvas.height);
                return;
            }
            const currentImg = processedImagesData[currentImageIndex];
            const originalWidth = currentImg.width; const originalHeight = currentImg.height;
            const container = backgroundMaskCanvas.parentElement;
            const displayWidth = container.clientWidth || backgroundMaskCanvas.width; 
            const displayHeight = container.clientHeight || backgroundMaskCanvas.height;

            const scale = Math.min(displayWidth / originalWidth, displayHeight / originalHeight, 3);
            const canvasWidth = Math.floor(originalWidth * scale); 
            const canvasHeight = Math.floor(originalHeight * scale);
            
            backgroundMaskCanvas.width = Math.max(1, canvasWidth); 
            backgroundMaskCanvas.height = Math.max(1, canvasHeight);
            
            const maskImageData = backgroundMaskCtx.createImageData(backgroundMaskCanvas.width, backgroundMaskCanvas.height);
            
            for (let y = 0; y < originalHeight; y++) {
                for (let x = 0; x < originalWidth; x++) {
                    const originalPixelIndex = y * originalWidth + x;
                    let originalPixelValue = Math.floor((1 - currentImg.data[originalPixelIndex]) * 255);
                    const isBackgroundPixel = backgroundMask[originalPixelIndex] === 1;
                    const startCanvasX = Math.floor(x * scale);
                    const startCanvasY = Math.floor(y * scale);
                    const endCanvasX = Math.floor((x + 1) * scale);
                    const endCanvasY = Math.floor((y + 1) * scale);

                    for (let cy = startCanvasY; cy < endCanvasY; cy++) {
                        for (let cx = startCanvasX; cx < endCanvasX; cx++) {
                            if (cx >= 0 && cx < backgroundMaskCanvas.width && cy >= 0 && cy < backgroundMaskCanvas.height) {
                                const scaledPixelIndex = (cy * backgroundMaskCanvas.width + cx) * 4;
                                if (isBackgroundPixel) {
                                    maskImageData.data[scaledPixelIndex] = 60; maskImageData.data[scaledPixelIndex + 1] = 60; maskImageData.data[scaledPixelIndex + 2] = 60;
                                } else {
                                    maskImageData.data[scaledPixelIndex] = originalPixelValue; maskImageData.data[scaledPixelIndex + 1] = originalPixelValue; maskImageData.data[scaledPixelIndex + 2] = originalPixelValue;
                                }
                                maskImageData.data[scaledPixelIndex + 3] = 255;
                            }
                        }
                    }
                }
            }
            backgroundMaskCtx.putImageData(maskImageData, 0, 0);
        }

        function updateNoiseChart() {
            if (noiseChart) noiseChart.destroy();
            if (!exposureTimes || !meanNoiseValuesArray || exposureTimes.length !== meanNoiseValuesArray.length || exposureTimes.length === 0) {
                const chartCtx = noiseChartCanvas.getContext('2d'); if(chartCtx) chartCtx.clearRect(0,0,noiseChartCanvas.width, noiseChartCanvas.height); return;
            }
            const ctx = noiseChartCanvas.getContext('2d');
            noiseChart = new Chart(ctx, { type: 'line', data: { labels: exposureTimes.map(String), datasets: [{ label: 'Mean Noise in Masked Area', data: meanNoiseValuesArray, borderColor: 'rgba(54, 162, 235, 1)', borderWidth: 2, fill: false, pointBackgroundColor: meanNoiseValuesArray.map((_, i) => i === currentImageIndex ? 'rgba(255, 99, 132, 1)' : 'rgba(54, 162, 235, 1)'), pointRadius: meanNoiseValuesArray.map((_, i) => i === currentImageIndex ? 7 : 5), lineTension: 0.1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Exposure Time (s) or Image Index' } }, y: { title: { display: true, text: 'Mean Noise Value' }, min: 0, suggestedMax: 0.05 } } } });
        }

        function handleHorizontalSliderChange(event) { horizontalIndex = parseInt(event.target.value); horizontalValue.textContent = horizontalIndex; }
        function handleVerticalSliderChange(event) { verticalIndex = parseInt(event.target.value); verticalValue.textContent = verticalIndex; }

        function drawCropSections() {
            const canvas = cropSectionsCanvas; const ctx = cropSectionsCtx; ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!inputCropData && !outputCropData) { ctx.font = "16px Arial"; ctx.fillStyle = "#777"; ctx.textAlign = "center"; ctx.fillText("No crop data available.", canvas.width/2, canvas.height/2); return; }
            let inputDisplayData = null; let outputDisplayData = null;
            if (inputCropData) inputDisplayData = normalizeDataByMax(inputCropData, getCentralPatchMax(inputCropData));
            if (outputCropData) outputDisplayData = normalizeDataByMax(outputCropData, getCentralPatchMax(outputCropData));
            const canvasSize = canvas.width; const halfSize = canvasSize / 2; const titlePadding = 25; const plotSize = halfSize; 
            ctx.fillStyle = '#f8f8f8'; ctx.fillRect(0, 0, canvasSize, canvasSize);
            ctx.fillStyle = '#333'; ctx.font = 'bold 13px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Input Crop', plotSize/2, titlePadding * 0.7); ctx.fillText('Vertical Section', halfSize + plotSize/2, titlePadding * 0.7);
            ctx.fillText('Horizontal Section', plotSize/2, halfSize + titlePadding * 0.7); ctx.fillText('Output Crop', halfSize + plotSize/2, halfSize + titlePadding * 0.7);
            ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(halfSize, 0); ctx.lineTo(halfSize, canvasSize); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, halfSize); ctx.lineTo(canvasSize, halfSize); ctx.stroke();
            const displayMaxValue = 1.0; 
            const plotAreaStartY = titlePadding; const plotAreaHeight = halfSize - titlePadding; const plotAreaWidth = halfSize; 
            if(inputDisplayData) drawImageToGrid(ctx, 0, plotAreaStartY, plotAreaWidth, plotAreaHeight, inputDisplayData, displayMaxValue);
            if(outputDisplayData) drawImageToGrid(ctx, halfSize, halfSize + plotAreaStartY, plotAreaWidth, plotAreaHeight, outputDisplayData, displayMaxValue);
            drawVerticalSection(ctx, halfSize, plotAreaStartY, plotAreaWidth, plotAreaHeight, displayMaxValue, inputDisplayData, outputDisplayData); 
            drawHorizontalSection(ctx, 0, halfSize + plotAreaStartY, plotAreaWidth, plotAreaHeight, displayMaxValue, inputDisplayData, outputDisplayData); 
            ctx.strokeStyle = 'rgba(255,0,0,0.7)'; ctx.lineWidth = 1; ctx.setLineDash([3, 3]);
            if (inputDisplayData) { 
                const inputPlotXStart = 0; const inputPlotYStart = plotAreaStartY; const inputPlotW = plotAreaWidth; const inputPlotH = plotAreaHeight;
                let linePosX_input = inputPlotXStart + (verticalIndex / (CROP_SIZE-1)) * inputPlotW;
                ctx.beginPath(); ctx.moveTo(linePosX_input, inputPlotYStart); ctx.lineTo(linePosX_input, inputPlotYStart + inputPlotH); ctx.stroke();
                let linePosY_input = inputPlotYStart + (horizontalIndex / (CROP_SIZE-1)) * inputPlotH;
                ctx.beginPath(); ctx.moveTo(inputPlotXStart, linePosY_input); ctx.lineTo(inputPlotXStart + inputPlotW, linePosY_input); ctx.stroke();
            }
            if (outputDisplayData) { 
                const outputPlotXStart = halfSize; const outputPlotYStart = halfSize + plotAreaStartY; const outputPlotW = plotAreaWidth; const outputPlotH = plotAreaHeight;
                let linePosX_output = outputPlotXStart + (verticalIndex / (CROP_SIZE-1)) * outputPlotW;
                ctx.beginPath(); ctx.moveTo(linePosX_output, outputPlotYStart); ctx.lineTo(linePosX_output, outputPlotYStart + outputPlotH); ctx.stroke();
                let linePosY_output = outputPlotYStart + (horizontalIndex / (CROP_SIZE-1)) * outputPlotH;
                ctx.beginPath(); ctx.moveTo(outputPlotXStart, linePosY_output); ctx.lineTo(outputPlotXStart + outputPlotW, linePosY_output); ctx.stroke();
            }
            ctx.setLineDash([]);
        }
        
        function drawImageToGrid(ctx, startX, startY, width, height, imageData, maxValue) {
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = CROP_SIZE; tempCanvas.height = CROP_SIZE; const tempCtx = tempCanvas.getContext('2d'); const imgData = tempCtx.createImageData(CROP_SIZE, CROP_SIZE);
            for (let i = 0; i < imageData.length; i++) { const val = Math.floor((1 - (imageData[i] / maxValue)) * 255); imgData.data[i * 4 + 0] = val; imgData.data[i * 4 + 1] = val; imgData.data[i * 4 + 2] = val; imgData.data[i * 4 + 3] = 255; }
            tempCtx.putImageData(imgData, 0, 0); ctx.imageSmoothingEnabled = false; ctx.drawImage(tempCanvas, startX, startY, width, height);
        }
        
        function drawVerticalSection(ctx, startX, startY, width, height, maxValue, inputProfileData, outputProfileData) { 
            ctx.fillStyle = '#f5f5f5'; ctx.fillRect(startX, startY, width, height); ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.strokeRect(startX, startY, width, height);
            let inputVertical = inputProfileData ? getVerticalSection(inputProfileData, verticalIndex) : null;
            let outputVertical = outputProfileData ? getVerticalSection(outputProfileData, verticalIndex) : null;
            const plotPath = (data, color) => { if (!data) return; ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.beginPath(); for (let i = 0; i < CROP_SIZE; i++) { const x = startX + (data[i]/maxValue) * width; const y = startY + (i / (CROP_SIZE-1)) * height; if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); } ctx.stroke(); };
            if(inputVertical) plotPath(inputVertical, 'blue'); if(outputVertical) plotPath(outputVertical, 'orange');
            const legendItems = outputVertical ? ['Input', 'Output'] : (inputVertical ? ['Input'] : []); if (legendItems.length > 0) drawLegend(ctx, startX + width - 60, startY + 5, legendItems);
        }
        
        function drawHorizontalSection(ctx, startX, startY, width, height, maxValue, inputProfileData, outputProfileData) { 
            ctx.fillStyle = '#f5f5f5'; ctx.fillRect(startX, startY, width, height); ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.strokeRect(startX, startY, width, height);
            let inputHorizontal = inputProfileData ? getHorizontalSection(inputProfileData, horizontalIndex) : null;
            let outputHorizontal = outputProfileData ? getHorizontalSection(outputProfileData, horizontalIndex) : null;
            const plotPath = (data, color) => { if (!data) return; ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.beginPath(); for (let i = 0; i < CROP_SIZE; i++) { const x = startX + (i / (CROP_SIZE-1)) * width; const y = startY + height - ((data[i]/maxValue) * height); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); } ctx.stroke(); };
            if(inputHorizontal) plotPath(inputHorizontal, 'blue'); if(outputHorizontal) plotPath(outputHorizontal, 'orange');
            const legendItems = outputHorizontal ? ['Input', 'Output'] : (inputHorizontal ? ['Input'] : []); if (legendItems.length > 0) drawLegend(ctx, startX + width - 60, startY + 5, legendItems);
        }

        function drawLegend(ctx, x, y, items) {
            ctx.font = '10px Arial'; ctx.textAlign = 'left'; const itemHeight = 15; const rectSize = 8; const textOffsetX = 12;
            items.forEach((item, index) => { let fillColor = (item === 'Input') ? 'blue' : (item === 'Output' ? 'orange' : '#333'); ctx.fillStyle = fillColor; ctx.fillRect(x, y + index * itemHeight, rectSize, rectSize); ctx.fillStyle = '#333'; ctx.fillText(item, x + textOffsetX, y + index * itemHeight + rectSize); });
        }
        
        function getHorizontalSection(data, row) { const result = new Float32Array(CROP_SIZE); for (let i = 0; i < CROP_SIZE; i++) result[i] = data[row * CROP_SIZE + i]; return result; }
        function getVerticalSection(data, col) { const result = new Float32Array(CROP_SIZE); for (let i = 0; i < CROP_SIZE; i++) result[i] = data[i * CROP_SIZE + col]; return result; }
        
        function handleNoiseThresholdInteraction() {
            const newThreshold = parseFloat(noiseThresholdSlider.value); BACKGROUND_THRESHOLD = newThreshold;
            const { means, mask, stats } = calculateMeanNoiseAndMask(processedImagesData, BACKGROUND_THRESHOLD);
            meanNoiseValuesArray = means; backgroundMask = mask;
            updateThresholdDisplay(BACKGROUND_THRESHOLD, stats.backgroundPercentage); updateNoiseChart(); drawBackgroundMaskVisualization();
        }

        function handleBandSelectionDisplaySliderChange(event) {
            currentBandSelectionDisplayIndex = parseInt(bandSelectionDisplaySlider.value);
            drawBandSelectionDisplayImage(); updateBandSelectionDisplayInfo();
        }

        function updateBandSelectionDisplayInfo() {
            if (!processedImagesData || processedImagesData.length === 0 || !exposureTimes || exposureTimes.length <= currentBandSelectionDisplayIndex) { bandSelectionDisplayInfo.textContent = "Display Exposure: N/A"; return; }
            const timeVal = (exposureTimes[currentBandSelectionDisplayIndex] !== undefined && typeof exposureTimes[currentBandSelectionDisplayIndex] === 'number') ? exposureTimes[currentBandSelectionDisplayIndex].toFixed(1) + "s" : "N/A";
            bandSelectionDisplayInfo.innerHTML = `Display Exposure: ${currentBandSelectionDisplayIndex + 1} of ${processedImagesData.length} (Time: ${timeVal})`; 
        }

        function drawBandSelectionDisplayImage() { 
            if (!processedImagesData || processedImagesData.length === 0 || currentBandSelectionDisplayIndex < 0 || currentBandSelectionDisplayIndex >= processedImagesData.length) {
                if (reconstructedIntensityCtx) reconstructedIntensityCtx.clearRect(0, 0, reconstructedIntensityCanvas.width, reconstructedIntensityCanvas.height); return;
            }
            const imgToDisplay = processedImagesData[currentBandSelectionDisplayIndex];
            reconstructedIntensityCanvas.width = imgToDisplay.width; reconstructedIntensityCanvas.height = imgToDisplay.height;
            const imageData = reconstructedIntensityCtx.createImageData(imgToDisplay.width, imgToDisplay.height);
            for (let i = 0; i < imgToDisplay.data.length; i++) {
                const val = Math.floor((1.0 - imgToDisplay.data[i]) * 255); 
                imageData.data[i * 4 + 0] = val; imageData.data[i * 4 + 1] = val; imageData.data[i * 4 + 2] = val; imageData.data[i * 4 + 3] = 255;
            }
            reconstructedIntensityCtx.putImageData(imageData, 0, 0);
            if (lastClickedPosition.x !== -1 && lastClickedPosition.y !== -1) { 
                 reconstructedIntensityCtx.strokeStyle = 'red'; reconstructedIntensityCtx.lineWidth = 0.5;
                 reconstructedIntensityCtx.beginPath(); reconstructedIntensityCtx.moveTo(0, lastClickedPosition.y); reconstructedIntensityCtx.lineTo(imgToDisplay.width, lastClickedPosition.y); reconstructedIntensityCtx.stroke();
                 reconstructedIntensityCtx.beginPath(); reconstructedIntensityCtx.moveTo(lastClickedPosition.x, 0); reconstructedIntensityCtx.lineTo(lastClickedPosition.x, imgToDisplay.height); reconstructedIntensityCtx.stroke();
                 reconstructedIntensityCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; reconstructedIntensityCtx.lineWidth = 1;
                 reconstructedIntensityCtx.strokeRect( Math.max(0, lastClickedPosition.x - CROP_SIZE / 2), Math.max(0, lastClickedPosition.y - CROP_SIZE / 2), CROP_SIZE, CROP_SIZE );
            }
        }

        function drawReconstructedPreviewImage() { 
            if (!reconstructedIntensityData || !reconstructedIntensityData.data) {
                if (reconstructedPreviewCtx) reconstructedPreviewCtx.clearRect(0, 0, reconstructedPreviewCanvas.width, reconstructedPreviewCanvas.height); return;
            }
            if (!reconstructedPreviewCanvas || !reconstructedPreviewCtx) return; 
            const img = reconstructedIntensityData; 
            reconstructedPreviewCanvas.width = img.width; reconstructedPreviewCanvas.height = img.height; 
            const imageData = reconstructedPreviewCtx.createImageData(img.width, img.height);
            for (let i = 0; i < img.data.length; i++) {
                const val = Math.floor((1.0 - img.data[i]) * 255); 
                imageData.data[i * 4 + 0] = val; imageData.data[i * 4 + 1] = val; imageData.data[i * 4 + 2] = val; imageData.data[i * 4 + 3] = 255;
            }
            reconstructedPreviewCtx.putImageData(imageData, 0, 0);
        }

        function updateSavedValuesTable() {
            if (!savedValuesTableHeader || !savedValuesTableBody) {
                console.error("Saved values table header or body not found!");
                return;
            }

            savedValuesTableHeader.innerHTML = '';
            savedValuesTableBody.innerHTML = '';

            const headerRow = savedValuesTableHeader.insertRow();
            let thClasses = "px-3 py-2 text-left font-semibold text-gray-700 uppercase tracking-wider sticky top-0 bg-gray-100 z-10";
            let th;

            th = headerRow.insertCell(); th.textContent = "Membrane"; th.className = thClasses;
            th = headerRow.insertCell(); th.textContent = "Protein";  th.className = thClasses;

            OPTIONS_2.forEach(laneName => {
                th = headerRow.insertCell(); 
                th.textContent = laneName; 
                th.className = thClasses + " text-center";
            });
            
            if (OPTIONS_1.length === 0 || OPTIONS_3.length === 0) {
                const tr = savedValuesTableBody.insertRow();
                const td = tr.insertCell();
                td.colSpan = 2 + OPTIONS_2.length; 
                td.textContent = "No categories defined to build the grid. Please manage categories.";
                td.className = "px-3 py-2 text-center text-gray-500 italic";
                return;
            }

            let firstRowOfTable = true;
            OPTIONS_1.forEach(membrane => {
                let firstProteinOfMembrane = true;
                OPTIONS_3.forEach((protein) => { // Removed proteinIndex as it's not strictly needed here
                    const tr = savedValuesTableBody.insertRow();
                    
                    if (!firstRowOfTable && firstProteinOfMembrane) {
                        tr.classList.add("border-t-2", "border-gray-400");
                    }

                    let tdMembrane = tr.insertCell();
                    if (firstProteinOfMembrane) {
                        tdMembrane.textContent = membrane;
                    }
                    tdMembrane.className = "px-3 py-2 whitespace-nowrap align-top font-medium text-gray-600"; 

                    let tdProtein = tr.insertCell();
                    tdProtein.textContent = protein;
                    tdProtein.className = "px-3 py-2 whitespace-nowrap";

                    OPTIONS_2.forEach(lane => {
                        let tdLane = tr.insertCell();
                        const resultEntry = resultsDict.find(r =>
                            r.Membrane === membrane &&
                            r.Protein === protein &&
                            r.Lane === lane
                        );

                        if (resultEntry) {
                            tdLane.textContent = resultEntry.OutputCropSum.toFixed(4);
                            tdLane.className = "px-3 py-2 whitespace-nowrap text-center";
                        } else {
                            tdLane.textContent = ""; 
                            tdLane.className = "px-3 py-2 whitespace-nowrap text-center";
                        }
                    });
                    firstProteinOfMembrane = false;
                    firstRowOfTable = false;
                });
            });
        }

        initialize();
    </script>
</body>
</html>